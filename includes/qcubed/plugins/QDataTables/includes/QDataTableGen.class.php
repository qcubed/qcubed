<?php
	/**
	 * QDataTableGen File
	 * 
	 * The abstract QDataTableGen class defined here is
	 * code-generated and contains options, events and methods scraped from the
	 * JQuery UI documentation Web site. It is not generated by the typical
	 * codegen process, but rather is generated periodically by the core QCubed
	 * team and checked in. However, the code to generate this file is
	 * in the assets/_core/php/_devetools/jquery_ui_gen/jq_control_gen.php file
	 * and you can regenerate the files if you need to.
	 *
	 * The comments in this file are taken from the JQuery UI site, so they do
	 * not always make sense with regard to QCubed. They are simply provided
	 * as reference. Note that this is very low-level code, and does not always
	 * update QCubed state variables. See the QDataTableBase 
	 * file, which contains code to interface between this generated file and QCubed.
	 *
	 * Because subsequent re-code generations will overwrite any changes to this
	 * file, you should leave this file unaltered to prevent yourself from losing
	 * any information or code changes.  All customizations should be done by
	 * overriding existing or implementing new methods, properties and variables
	 * in the QDataTable class file.
	 *
	 */

	/* Custom event classes for this control */
	
	

	/* Custom "property" event classes for this control */

	/**
	 * Generated QDataTableGen class.
	 * 
	 * This is the QDataTableGen class which is automatically generated
	 * by scraping the JQuery UI documentation website. As such, it includes all the options
	 * as listed by the JQuery UI website, which may or may not be appropriate for QCubed. See
	 * the QDataTableBase class for any glue code to make this class more
	 * usable in QCubed.
	 * 
	 * @see QDataTableBase
	 * @package Controls\Base
	 * @property array $Columns Columns
	 * @property array $ColumnDefs Column Definitions
	 * @property mixed $Language Language object
	 * @property array $Data An array of data to use for the table, passed in at initialisation which  
	 * 		will be used in preference to any data which is already in the DOM. This is
	 * 		 particularly useful for constructing tables purely in Javascript, for 
	 * 		example with a custom Ajax call.
	 * @property array $Sorting If sorting is enabled, then DataTables will perform a first pass sort on  
	 * 		initialisation. You can define which column(s) the sort is performed upon, 
	 * 		 and the sorting direction, with this variable. The aaSorting array should 
	 * 		 contain an array for each column to be sorted initially containing the  
	 * 		column's index and a direction string ('asc' or 'desc').
	 * @property array $SortingFixed This parameter is basically identical to the aaSorting parameter, but  
	 * 		cannot be overridden by user interaction with the table. What this means  
	 * 		is that you could have a column (visible or hidden) which the sorting will 
	 * 		 always be forced on first - any sorting after that (from the user) will  
	 * 		then be performed as required. This can be useful for grouping rows  
	 * 		together.
	 * @property int[] $LengthMenuArray This parameter allows you to readily specify the entries in the length drop
	 * 		 down menu that DataTables shows when pagination is enabled. It can be  
	 * 		either a 1D array of options which will be used for both the displayed  
	 * 		option and the value, or a 2D array which will use the array in the first  
	 * 		position as the value, and the array in the second position as the  
	 * 		displayed options (useful for language strings such as 'All').
	 * @property object[] $SearchColsArray Basically the same as oSearch, this parameter defines the individual column
	 * 		 filtering state at initialisation time. The array must be of the same size
	 * 		  as the number of columns, and each element be an object with the
	 * 		parameters  "sSearch" and "bEscapeRegex" (the latter is optional). 'null'
	 * 		is also  accepted and the default will be used.
	 * @property string[] $StripeClassesArray An array of CSS classes that should be applied to displayed rows. This  
	 * 		array may be of any length, and DataTables will apply each class  
	 * 		sequentially, looping when required.
	 * @property boolean $AutoWidth Enable or disable automatic column width calculation. This can be disabled 
	 * 		as an optimisation (it takes some time to calculate the widths) if the 
	 * 		tables widths are passed in using aoColumns.
	 * @property boolean $DeferRender Deferred rendering can provide DataTables with a huge speed boost when you 
	 * 		are using an Ajax or JS data source for the table. This option, when set to
	 * 		 true, will cause DataTables to defer the creation of the table elements
	 * 		for  each row until they are needed for a draw - saving a significant
	 * 		amount of  time.
	 * @property boolean $Destroy Replace a DataTable which matches the given selector and replace it with  
	 * 		one which has the properties of the new initialisation object passed. If no
	 * 		 table matches the selector, then the new DataTable will be constructed as 
	 * 		per normal.
	 * @property boolean $Filter Enable or disable filtering of data. Filtering in DataTables is "smart" in 
	 * 		that it allows the end user to input multiple words (space separated) and 
	 * 		will match a row containing those words, even if not in the order that was 
	 * 		specified (this allow matching across multiple columns). Note that if you 
	 * 		wish to use filtering in DataTables this must remain 'true' - to remove the
	 * 		 default filtering input box and retain filtering abilities, please use
	 * @property boolean $Info Enable or disable the table information display. This shows information  
	 * 		about the data that is currently visible on the page, including information
	 * 		 about filtered data if that action is being performed.
	 * @property boolean $JQueryUI Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
	 * 		 slightly different and additional mark-up from what DataTables has 
	 * 		traditionally used).
	 * @property boolean $LengthChange Allows the end user to select the size of a formatted page from a select 
	 * 		menu (sizes are 10, 25, 50 and 100). Requires pagination (bPaginate).
	 * @property boolean $Paginate Enable or disable pagination.
	 * @property boolean $Processing Enable or disable the display of a 'processing' indicator when the table is
	 * 		 being processed (e.g. a sort). This is particularly useful for tables with
	 * 		 large amounts of data where it can take a noticeable amount of time to
	 * 		sort  the entries.
	 * @property boolean $Retrieve Retrieve the DataTables object for the given selector. Note that if the 
	 * 		table has already been initialised, this parameter will cause DataTables 
	 * 		to simply return the object that has already been set up - it will not take
	 * 		 account of any changes you might have made to the initialisation object 
	 * 		passed to DataTables (setting this parameter to true is an acknowledgement 
	 * 		that you understand this). bDestroy can be used to reinitialise a table if 
	 * 		you need.
	 * @property boolean $ScrollAutoCss Indicate if DataTables should be allowed to set the padding / margin  etc
	 * 		for the scrolling header elements or not. Typically you will want  this.
	 * @property boolean $ScrollCollapse When vertical (y) scrolling is enabled, DataTables will force the height of
	 * 		 the table's viewport to the given height at all times (useful for layout).
	 * 		 However, this can look odd when filtering data down to a small data set, 
	 * 		and the footer is left "floating" further down. This parameter (when 
	 * 		enabled) will cause DataTables to collapse the table's viewport down when 
	 * 		the result set will fit within the given Y height.
	 * @property boolean $ScrollInfinite Enable infinite scrolling for DataTables (to be used in combination with 
	 * 		sScrollY). Infinite scrolling means that DataTables will continually load 
	 * 		data as a user scrolls through a table, which is very useful for large 
	 * 		dataset. This cannot be used with pagination, which is automatically 
	 * 		disabled. Note - the Scroller extra for DataTables is recommended in  in
	 * 		preference to this option.
	 * @property boolean $ServerSide Configure DataTables to use server-side processing. Note that the 
	 * 		sAjaxSource parameter must also be given in order to give DataTables a 
	 * 		source to obtain the required data for each draw.
	 * @property boolean $ServerSide1 Configure DataTables to use server-side processing. Note that the 
	 * 		sAjaxSource parameter must also be given in order to give DataTables a 
	 * 		source to obtain the required data for each draw.
	 * @property boolean $Sort Enable or disable sorting of columns. Sorting of individual columns can be 
	 * 		disabled by the "bSortable" option for each column.
	 * @property boolean $SortCellsTop Allows control over whether DataTables should use the top (true) unique 
	 * 		cell that is found for a single column, or the bottom (false - default). 
	 * 		This is useful when using complex headers.
	 * @property boolean $SortClasses Enable or disable the addition of the classes 'sorting_1', 'sorting_2' and 
	 * 		'sorting_3' to the columns which are currently being sorted on. This is 
	 * 		presented as a feature switch as it can increase processing time (while 
	 * 		classes are removed and added) so for large data sets you might want to 
	 * 		turn this off.
	 * @property boolean $StateSave Enable or disable state saving. When enabled a cookie will be used to save 
	 * 		table display information such as pagination information, display length, 
	 * 		filtering and sorting. As such when the end user reloads the page the 
	 * 		display display will match what thy had previously set up.
	 * @property QJsClosure $CookieCallback Customise the cookie and / or the parameters being stored when using 
	 * 		DataTables with state saving enabled. This function is called whenever  the
	 * 		cookie is modified, and it expects a fully formed cookie string to be 
	 * 		returned. Note that the data object passed in is a Javascript object which 
	 * 		must be converted to a string (JSON.stringify for example).
	 * @property QJsClosure $CreatedRow This function is called when a TR element is created (and all TD child 
	 * 		elements have been inserted), or registered if using a DOM source, allowing
	 * 		 manipulation of the TR element (adding classes etc).
	 * @property QJsClosure $DrawCallback This function is called on every 'draw' event, and allows you to 
	 * 		dynamically modify any aspect you want about the created DOM.
	 * @property QJsClosure $FooterCallback Identical to fnHeaderCallback() but for the table footer this function 
	 * 		allows you to modify the table footer on every 'draw' even.
	 * @property QJsClosure $FormatNumber When rendering large numbers in the information element for the table 
	 * 		(i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
	 * 		 to have a comma separator for the 'thousands' units (e.g. 1 million is 
	 * 		rendered as "1,000,000") to help readability for the end user. This 
	 * 		function will override the default method DataTables uses.
	 * @property QJsClosure $HeaderCallback This function is called on every 'draw' event, and allows you to 
	 * 		dynamically modify the header row. This can be used to calculate and 
	 * 		display useful information about the table.
	 * @property QJsClosure $InfoCallback The information element can be used to convey information about the current
	 * 		 state of the table. Although the internationalisation options presented by
	 * 		 DataTables are quite capable of dealing with most customisations, there
	 * 		may  be times where you wish to customise the string further. This callback
	 * 		 allows you to do exactly that.
	 * @property QJsClosure $InitComplete Called when the table has been initialised. Normally DataTables will 
	 * 		initialise sequentially and there will be no need for this function, 
	 * 		however, this does not hold true when using external language information 
	 * 		since that is obtained using an async XHR call.
	 * @property QJsClosure $PreDrawCallback Called at the very start of each table draw and can be used to cancel the 
	 * 		draw by returning false, any other return (including undefined) results in 
	 * 		the full draw occurring).
	 * @property QJsClosure $RowCallback This function allows you to 'post process' each row after it have been 
	 * 		generated for each table draw, but before it is rendered on screen. This 
	 * 		function might be used for setting the row class name etc.
	 * @property QJsClosure $ServerData This parameter allows you to override the default function which obtains 
	 * 		the data from the server ($.getJSON) so something more suitable for your 
	 * 		application. For example you could use POST data, or pull information from 
	 * 		a Gears or AIR database.
	 * @property QJsClosure $ServerData1 This parameter allows you to override the default function which obtains 
	 * 		the data from the server ($.getJSON) so something more suitable for your 
	 * 		application. For example you could use POST data, or pull information from 
	 * 		a Gears or AIR database.
	 * @property QJsClosure $ServerParams It is often useful to send extra data to the server when making an Ajax 
	 * 		request - for example custom filtering information, and this callback 
	 * 		function makes it trivial to send extra information to the server. The 
	 * 		passed in parameter is the data set that has been constructed by 
	 * 		DataTables, and you can add to this or modify it as you require.
	 * @property QJsClosure $ServerParams1 It is often useful to send extra data to the server when making an Ajax 
	 * 		request - for example custom filtering information, and this callback 
	 * 		function makes it trivial to send extra information to the server. The 
	 * 		passed in parameter is the data set that has been constructed by 
	 * 		DataTables, and you can add to this or modify it as you require.
	 * @property QJsClosure $StateLoad Load the table state. With this function you can define from where, and
	 * 		how, the  state of a table is loaded. By default DataTables will load from
	 * 		its state saving  cookie, but you might wish to use local storage (HTML5)
	 * 		or a server-side database.
	 * @property QJsClosure $StateLoaded Callback that is called when the state has been loaded from the state
	 * 		saving method  and the DataTables settings object has been modified as a
	 * 		result of the loaded state.
	 * @property QJsClosure $StateLoadParams Callback which allows modification of the saved state prior to loading that
	 * 		state.  This callback is called when the table is loading state from the
	 * 		stored data, but  prior to the settings object being modified by the saved
	 * 		state. Note that for   plug-in authors, you should use the
	 * 		'stateLoadParams' event to load parameters for   a plug-in.
	 * @property QJsClosure $StateSave1 Save the table state. This function allows you to define where and how the
	 * 		state  information for the table is stored - by default it will use a
	 * 		cookie, but you  might want to use local storage (HTML5) or a server-side
	 * 		database.
	 * @property QJsClosure $StateSaveParams Callback which allows modification of the state to be saved. Called when
	 * 		the table   has changed state a new state save is required. This method
	 * 		allows modification of  the state saving object prior to actually doing the
	 * 		save, including addition or   other state properties or modification. Note
	 * 		that for plug-in authors, you should   use the 'stateSaveParams' event to
	 * 		save parameters for a plug-in.
	 * @property integer $CookieDuration Duration of the cookie which is used for storing session information. This 
	 * 		value is given in seconds.
	 * @property integer $DeferLoading When enabled DataTables will not make a request to the server for the first
	 * 		 page draw - rather it will use the data already on the page (no sorting
	 * 		etc  will be applied to it), thus saving on an XHR at load time.
	 * 		iDeferLoading  is used to indicate that deferred loading is required, but
	 * 		it is also used  to tell DataTables how many records there are in the full
	 * 		table (allowing  the information element and pagination to be displayed
	 * 		correctly).
	 * @property integer $DisplayLength Number of rows to display on a single page when using pagination. If 
	 * 		feature enabled (bLengthChange) then the end user will be able to override 
	 * 		this to a custom setting using a pop-up menu.
	 * @property integer $DisplayStart Define the starting point for data display when using DataTables with 
	 * 		pagination. Note that this parameter is the number of records, rather than 
	 * 		the page number, so if you have 10 records per page and want to start on 
	 * 		the third page, it should be "20".
	 * @property integer $ScrollLoadGap The scroll gap is the amount of scrolling that is left to go before 
	 * 		DataTables will load the next 'page' of data automatically. You typically 
	 * 		want a gap which is big enough that the scrolling will be smooth for the 
	 * 		user, while not so large that it will load more data than need.
	 * @property integer $TabIndex By default DataTables allows keyboard navigation of the table (sorting,
	 * 		paging,  and filtering) by adding a tabindex attribute to the required
	 * 		elements. This  allows you to tab through the controls and press the enter
	 * 		key to activate them.  The tabindex is default 0, meaning that the tab
	 * 		follows the flow of the document.  You can overrule this using this
	 * 		parameter if you wish. Use a value of -1 to  disable built-in keyboard
	 * 		navigation.
	 * @property mixed $Search This parameter allows you to have define the global filtering state at 
	 * 		initialisation time. As an object the "sSearch" parameter must be  defined,
	 * 		but all other parameters are optional. When "bRegex" is true,  the search
	 * 		string will be treated as a regular expression, when false  (default) it
	 * 		will be treated as a straight string. When "bSmart"  DataTables will use
	 * 		it's smart filtering methods (to word match at  any point in the data),
	 * 		when false this will not be done.
	 * @property string $AjaxDataProp By default DataTables will look for the property 'aaData' when obtaining 
	 * 		data from an Ajax source or for server-side processing - this parameter 
	 * 		allows that property to be changed. You can use Javascript dotted object 
	 * 		notation to get a data source for multiple levels of nesting.
	 * @property string $AjaxDataProp1 By default DataTables will look for the property 'aaData' when obtaining 
	 * 		data from an Ajax source or for server-side processing - this parameter 
	 * 		allows that property to be changed. You can use Javascript dotted object 
	 * 		notation to get a data source for multiple levels of nesting.
	 * @property string $AjaxSource You can instruct DataTables to load data from an external source using this
	 * 		 parameter (use aData if you want to pass data in you already have). Simply
	 * 		 provide a url a JSON object can be obtained from. This object must include
	 * 		 the parameter 'aaData' which is the data source for the table.
	 * @property string $AjaxSource1 You can instruct DataTables to load data from an external source using this
	 * 		 parameter (use aData if you want to pass data in you already have). Simply
	 * 		 provide a url a JSON object can be obtained from. This object must include
	 * 		 the parameter 'aaData' which is the data source for the table.
	 * @property string $CookiePrefix This parameter can be used to override the default prefix that DataTables 
	 * 		assigns to a cookie when state saving is enabled.
	 * @property string $Dom This initialisation variable allows you to specify exactly where in the 
	 * 		DOM you want DataTables to inject the various controls it adds to the page 
	 * 		(for example you might want the pagination controls at the top of the 
	 * 		table). DIV elements (with or without a custom class) can also be added to 
	 * 		aid styling. The follow syntax is used:          The following options are
	 * 		allowed:	                  'l' - Length changing'f' - Filtering input      
	 * 		   't' - The table!          'i' - Information          'p' - Pagination   
	 * 		      'r' - pRocessing                    The following constants are
	 * 		allowed:                  'H' - jQueryUI theme "header" classes
	 * 		('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr
	 * 		ui-helper-clearfix')          'F' - jQueryUI theme "footer" classes
	 * 		('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br
	 * 		ui-helper-clearfix')                    The following syntax is expected:  
	 * 		               '&lt;' and '&gt;' - div elements          '&lt;"class" and
	 * 		'&gt;' - div with a class          '&lt;"#id" and '&gt;' - div with an ID  
	 * 		                 Examples:                  '&lt;"wrapper"flipt&gt;'       
	 * 		  '&lt;lf&lt;t&gt;ip&gt;'
	 * @property string $PaginationType DataTables features two different built-in pagination interaction methods 
	 * 		('two_button' or 'full_numbers') which present different page controls to 
	 * 		the end user. Further methods can be added using the API (see below).
	 * @property string $ScrollX Enable horizontal scrolling. When a table is too wide to fit into a certain
	 * 		 layout, or you have a large number of columns in the table, you can enable
	 * 		 x-scrolling to show the table in a viewport, which can be scrolled. This 
	 * 		property can by any CSS unit, or a number (in which case it will be treated
	 * 		 as a pixel measurement).
	 * @property string $ScrollXInner This property can be used to force a DataTable to use more width than it 
	 * 		might otherwise do when x-scrolling is enabled. For example if you have a 
	 * 		table which requires to be well spaced, this parameter is useful for 
	 * 		"over-sizing" the table, and thus forcing scrolling. This property can by 
	 * 		any CSS unit, or a number (in which case it will be treated as a pixel 
	 * 		measurement).
	 * @property string $ScrollY Enable vertical scrolling. Vertical scrolling will constrain the DataTable 
	 * 		to the given height, an enable scrolling for any data which overflows the 
	 * 		current viewport. This can be used as an alternative to paging to display 
	 * 		a lot of data in a small area (although paging and scrolling can both be 
	 * 		enabled at the same time). This property can by any CSS unit, or a number 
	 * 		(in which case it will be treated as a pixel measurement).
	 * @property string $ServerMethod Set the HTTP method that is used to make the Ajax call for server-side 
	 * 		processing or Ajax sourced data.
	 * @property string $ServerMethod1 Set the HTTP method that is used to make the Ajax call for server-side 
	 * 		processing or Ajax sourced data.
	 */

	class QDataTableGen extends QSimpleTable	{
		protected $strJavaScripts = __JQUERY_EFFECTS__;
		protected $strStyleSheets = __JQUERY_CSS__;
		/** @var array */
		protected $arrColumns;
		/** @var array */
		protected $arrColumnDefs;
		/** @var mixed */
		protected $mixLanguage;
		/** @var array */
		protected $arrData;
		/** @var array */
		protected $arrSorting;
		/** @var array */
		protected $arrSortingFixed;
		/** @var int[] */
		protected $intLengthMenuArray;
		/** @var object[] */
		protected $mixSearchColsArray;
		/** @var string[] */
		protected $strStripeClassesArray;
		/** @var boolean */
		protected $blnAutoWidth = null;
		/** @var boolean */
		protected $blnDeferRender = null;
		/** @var boolean */
		protected $blnDestroy = null;
		/** @var boolean */
		protected $blnFilter = null;
		/** @var boolean */
		protected $blnInfo = null;
		/** @var boolean */
		protected $blnJQueryUI = null;
		/** @var boolean */
		protected $blnLengthChange = null;
		/** @var boolean */
		protected $blnPaginate = null;
		/** @var boolean */
		protected $blnProcessing = null;
		/** @var boolean */
		protected $blnRetrieve = null;
		/** @var boolean */
		protected $blnScrollAutoCss = null;
		/** @var boolean */
		protected $blnScrollCollapse = null;
		/** @var boolean */
		protected $blnScrollInfinite = null;
		/** @var boolean */
		protected $blnServerSide = null;
		/** @var boolean */
		protected $blnServerSide1 = null;
		/** @var boolean */
		protected $blnSort = null;
		/** @var boolean */
		protected $blnSortCellsTop = null;
		/** @var boolean */
		protected $blnSortClasses = null;
		/** @var boolean */
		protected $blnStateSave = null;
		/** @var QJsClosure */
		protected $mixCookieCallback;
		/** @var QJsClosure */
		protected $mixCreatedRow;
		/** @var QJsClosure */
		protected $mixDrawCallback;
		/** @var QJsClosure */
		protected $mixFooterCallback;
		/** @var QJsClosure */
		protected $mixFormatNumber;
		/** @var QJsClosure */
		protected $mixHeaderCallback;
		/** @var QJsClosure */
		protected $mixInfoCallback;
		/** @var QJsClosure */
		protected $mixInitComplete;
		/** @var QJsClosure */
		protected $mixPreDrawCallback;
		/** @var QJsClosure */
		protected $mixRowCallback;
		/** @var QJsClosure */
		protected $mixServerData;
		/** @var QJsClosure */
		protected $mixServerData1;
		/** @var QJsClosure */
		protected $mixServerParams;
		/** @var QJsClosure */
		protected $mixServerParams1;
		/** @var QJsClosure */
		protected $mixStateLoad;
		/** @var QJsClosure */
		protected $mixStateLoaded;
		/** @var QJsClosure */
		protected $mixStateLoadParams;
		/** @var QJsClosure */
		protected $mixStateSave1;
		/** @var QJsClosure */
		protected $mixStateSaveParams;
		/** @var integer */
		protected $intCookieDuration = null;
		/** @var integer */
		protected $intDeferLoading = null;
		/** @var integer */
		protected $intDisplayLength = null;
		/** @var integer */
		protected $intDisplayStart = null;
		/** @var integer */
		protected $intScrollLoadGap = null;
		/** @var integer */
		protected $intTabIndex = null;
		/** @var mixed */
		protected $mixSearch;
		/** @var string */
		protected $strAjaxDataProp = null;
		/** @var string */
		protected $strAjaxDataProp1 = null;
		/** @var string */
		protected $strAjaxSource = null;
		/** @var string */
		protected $strAjaxSource1 = null;
		/** @var string */
		protected $strCookiePrefix = null;
		/** @var string */
		protected $strDom = null;
		/** @var string */
		protected $strPaginationType = null;
		/** @var string */
		protected $strScrollX = null;
		/** @var string */
		protected $strScrollXInner = null;
		/** @var string */
		protected $strScrollY = null;
		/** @var string */
		protected $strServerMethod = null;
		/** @var string */
		protected $strServerMethod1 = null;
		
		protected function makeJsProperty($strProp, $strKey) {
			$objValue = $this->$strProp;
			if (null === $objValue) {
				return '';
			}

			return $strKey . ': ' . JavaScriptHelper::toJsObject($objValue) . ', ';
		}

		protected function makeJqOptions() {
			$strJqOptions = '';
			$strJqOptions .= $this->makeJsProperty('Columns', 'aoColumns');
			$strJqOptions .= $this->makeJsProperty('ColumnDefs', 'aoColumnDefs');
			$strJqOptions .= $this->makeJsProperty('Language', 'oLanguage');
			$strJqOptions .= $this->makeJsProperty('Data', 'aaData');
			$strJqOptions .= $this->makeJsProperty('Sorting', 'aaSorting');
			$strJqOptions .= $this->makeJsProperty('SortingFixed', 'aaSortingFixed');
			$strJqOptions .= $this->makeJsProperty('LengthMenuArray', 'aLengthMenu');
			$strJqOptions .= $this->makeJsProperty('SearchColsArray', 'aoSearchCols');
			$strJqOptions .= $this->makeJsProperty('StripeClassesArray', 'asStripeClasses');
			$strJqOptions .= $this->makeJsProperty('AutoWidth', 'bAutoWidth');
			$strJqOptions .= $this->makeJsProperty('DeferRender', 'bDeferRender');
			$strJqOptions .= $this->makeJsProperty('Destroy', 'bDestroy');
			$strJqOptions .= $this->makeJsProperty('Filter', 'bFilter');
			$strJqOptions .= $this->makeJsProperty('Info', 'bInfo');
			$strJqOptions .= $this->makeJsProperty('JQueryUI', 'bJQueryUI');
			$strJqOptions .= $this->makeJsProperty('LengthChange', 'bLengthChange');
			$strJqOptions .= $this->makeJsProperty('Paginate', 'bPaginate');
			$strJqOptions .= $this->makeJsProperty('Processing', 'bProcessing');
			$strJqOptions .= $this->makeJsProperty('Retrieve', 'bRetrieve');
			$strJqOptions .= $this->makeJsProperty('ScrollAutoCss', 'bScrollAutoCss');
			$strJqOptions .= $this->makeJsProperty('ScrollCollapse', 'bScrollCollapse');
			$strJqOptions .= $this->makeJsProperty('ScrollInfinite', 'bScrollInfinite');
			$strJqOptions .= $this->makeJsProperty('ServerSide', 'bServerSide');
			$strJqOptions .= $this->makeJsProperty('ServerSide1', 'bServerSide');
			$strJqOptions .= $this->makeJsProperty('Sort', 'bSort');
			$strJqOptions .= $this->makeJsProperty('SortCellsTop', 'bSortCellsTop');
			$strJqOptions .= $this->makeJsProperty('SortClasses', 'bSortClasses');
			$strJqOptions .= $this->makeJsProperty('StateSave', 'bStateSave');
			$strJqOptions .= $this->makeJsProperty('CookieCallback', 'fnCookieCallback');
			$strJqOptions .= $this->makeJsProperty('CreatedRow', 'fnCreatedRow');
			$strJqOptions .= $this->makeJsProperty('DrawCallback', 'fnDrawCallback');
			$strJqOptions .= $this->makeJsProperty('FooterCallback', 'fnFooterCallback');
			$strJqOptions .= $this->makeJsProperty('FormatNumber', 'fnFormatNumber');
			$strJqOptions .= $this->makeJsProperty('HeaderCallback', 'fnHeaderCallback');
			$strJqOptions .= $this->makeJsProperty('InfoCallback', 'fnInfoCallback');
			$strJqOptions .= $this->makeJsProperty('InitComplete', 'fnInitComplete');
			$strJqOptions .= $this->makeJsProperty('PreDrawCallback', 'fnPreDrawCallback');
			$strJqOptions .= $this->makeJsProperty('RowCallback', 'fnRowCallback');
			$strJqOptions .= $this->makeJsProperty('ServerData', 'fnServerData');
			$strJqOptions .= $this->makeJsProperty('ServerData1', 'fnServerData');
			$strJqOptions .= $this->makeJsProperty('ServerParams', 'fnServerParams');
			$strJqOptions .= $this->makeJsProperty('ServerParams1', 'fnServerParams');
			$strJqOptions .= $this->makeJsProperty('StateLoad', 'fnStateLoad');
			$strJqOptions .= $this->makeJsProperty('StateLoaded', 'fnStateLoaded');
			$strJqOptions .= $this->makeJsProperty('StateLoadParams', 'fnStateLoadParams');
			$strJqOptions .= $this->makeJsProperty('StateSave1', 'fnStateSave');
			$strJqOptions .= $this->makeJsProperty('StateSaveParams', 'fnStateSaveParams');
			$strJqOptions .= $this->makeJsProperty('CookieDuration', 'iCookieDuration');
			$strJqOptions .= $this->makeJsProperty('DeferLoading', 'iDeferLoading');
			$strJqOptions .= $this->makeJsProperty('DisplayLength', 'iDisplayLength');
			$strJqOptions .= $this->makeJsProperty('DisplayStart', 'iDisplayStart');
			$strJqOptions .= $this->makeJsProperty('ScrollLoadGap', 'iScrollLoadGap');
			$strJqOptions .= $this->makeJsProperty('TabIndex', 'iTabIndex');
			$strJqOptions .= $this->makeJsProperty('Search', 'oSearch');
			$strJqOptions .= $this->makeJsProperty('AjaxDataProp', 'sAjaxDataProp');
			$strJqOptions .= $this->makeJsProperty('AjaxDataProp1', 'sAjaxDataProp');
			$strJqOptions .= $this->makeJsProperty('AjaxSource', 'sAjaxSource');
			$strJqOptions .= $this->makeJsProperty('AjaxSource1', 'sAjaxSource');
			$strJqOptions .= $this->makeJsProperty('CookiePrefix', 'sCookiePrefix');
			$strJqOptions .= $this->makeJsProperty('Dom', 'sDom');
			$strJqOptions .= $this->makeJsProperty('PaginationType', 'sPaginationType');
			$strJqOptions .= $this->makeJsProperty('ScrollX', 'sScrollX');
			$strJqOptions .= $this->makeJsProperty('ScrollXInner', 'sScrollXInner');
			$strJqOptions .= $this->makeJsProperty('ScrollY', 'sScrollY');
			$strJqOptions .= $this->makeJsProperty('ServerMethod', 'sServerMethod');
			$strJqOptions .= $this->makeJsProperty('ServerMethod1', 'sServerMethod');
			if ($strJqOptions) $strJqOptions = substr($strJqOptions, 0, -2);
			return $strJqOptions;
		}

		public function getJqSetupFunction() {
			return 'dataTable';
		}

		public function GetControlJavaScript() {
			return sprintf('jQuery("#%s").%s({%s})', $this->getJqControlId(), $this->getJqSetupFunction(), $this->makeJqOptions());
		}

		public function GetEndScript() {
			$str = '';
			if ($this->getJqControlId() !== $this->ControlId) {
				// #845: if the element receiving the jQuery UI events is different than this control
				// we need to clean-up the previously attached event handlers, so that they are not duplicated 
				// during the next ajax update which replaces this control.
				$str = sprintf('jQuery("#%s").off(); ', $this->getJqControlId());
			}
			$str .= $this->GetControlJavaScript();
			if ($strParentScript = parent::GetEndScript()) {
				$str .= '; ' . $strParentScript;
			}
			return $str;
		}
		
		/**
		 * Call a JQuery UI Method on the object. 
		 * 
		 * A helper function to call a jQuery UI Method. Takes variable number of arguments.
		 *
		 * @param boolean $blnAttribute true if the method is modifying an option, false if executing a command
		 * @param string $strMethodName the method name to call
		 * @internal param $mixed [optional] $mixParam1
		 * @internal param $mixed [optional] $mixParam2
		 */
		protected function CallJqUiMethod($blnAttribute, $strMethodName /*, ... */) {
			$args = func_get_args();
			array_shift ($args);

			$strArgs = JavaScriptHelper::toJsObject($args);
			$strJs = sprintf('jQuery("#%s").%s(%s)',
				$this->getJqControlId(),
				$this->getJqSetupFunction(),
				substr($strArgs, 1, strlen($strArgs)-2));	// params without brackets
			if ($blnAttribute) {
				$this->AddAttributeScript($strJs);
			} else {
				QApplication::ExecuteJavaScript($strJs);
			}
		}




		public function __get($strName) {
			switch ($strName) {
				case 'Columns': return $this->arrColumns;
				case 'ColumnDefs': return $this->arrColumnDefs;
				case 'Language': return $this->mixLanguage;
				case 'Data': return $this->arrData;
				case 'Sorting': return $this->arrSorting;
				case 'SortingFixed': return $this->arrSortingFixed;
				case 'LengthMenuArray': return $this->intLengthMenuArray;
				case 'SearchColsArray': return $this->mixSearchColsArray;
				case 'StripeClassesArray': return $this->strStripeClassesArray;
				case 'AutoWidth': return $this->blnAutoWidth;
				case 'DeferRender': return $this->blnDeferRender;
				case 'Destroy': return $this->blnDestroy;
				case 'Filter': return $this->blnFilter;
				case 'Info': return $this->blnInfo;
				case 'JQueryUI': return $this->blnJQueryUI;
				case 'LengthChange': return $this->blnLengthChange;
				case 'Paginate': return $this->blnPaginate;
				case 'Processing': return $this->blnProcessing;
				case 'Retrieve': return $this->blnRetrieve;
				case 'ScrollAutoCss': return $this->blnScrollAutoCss;
				case 'ScrollCollapse': return $this->blnScrollCollapse;
				case 'ScrollInfinite': return $this->blnScrollInfinite;
				case 'ServerSide': return $this->blnServerSide;
				case 'ServerSide1': return $this->blnServerSide1;
				case 'Sort': return $this->blnSort;
				case 'SortCellsTop': return $this->blnSortCellsTop;
				case 'SortClasses': return $this->blnSortClasses;
				case 'StateSave': return $this->blnStateSave;
				case 'CookieCallback': return $this->mixCookieCallback;
				case 'CreatedRow': return $this->mixCreatedRow;
				case 'DrawCallback': return $this->mixDrawCallback;
				case 'FooterCallback': return $this->mixFooterCallback;
				case 'FormatNumber': return $this->mixFormatNumber;
				case 'HeaderCallback': return $this->mixHeaderCallback;
				case 'InfoCallback': return $this->mixInfoCallback;
				case 'InitComplete': return $this->mixInitComplete;
				case 'PreDrawCallback': return $this->mixPreDrawCallback;
				case 'RowCallback': return $this->mixRowCallback;
				case 'ServerData': return $this->mixServerData;
				case 'ServerData1': return $this->mixServerData1;
				case 'ServerParams': return $this->mixServerParams;
				case 'ServerParams1': return $this->mixServerParams1;
				case 'StateLoad': return $this->mixStateLoad;
				case 'StateLoaded': return $this->mixStateLoaded;
				case 'StateLoadParams': return $this->mixStateLoadParams;
				case 'StateSave1': return $this->mixStateSave1;
				case 'StateSaveParams': return $this->mixStateSaveParams;
				case 'CookieDuration': return $this->intCookieDuration;
				case 'DeferLoading': return $this->intDeferLoading;
				case 'DisplayLength': return $this->intDisplayLength;
				case 'DisplayStart': return $this->intDisplayStart;
				case 'ScrollLoadGap': return $this->intScrollLoadGap;
				case 'TabIndex': return $this->intTabIndex;
				case 'Search': return $this->mixSearch;
				case 'AjaxDataProp': return $this->strAjaxDataProp;
				case 'AjaxDataProp1': return $this->strAjaxDataProp1;
				case 'AjaxSource': return $this->strAjaxSource;
				case 'AjaxSource1': return $this->strAjaxSource1;
				case 'CookiePrefix': return $this->strCookiePrefix;
				case 'Dom': return $this->strDom;
				case 'PaginationType': return $this->strPaginationType;
				case 'ScrollX': return $this->strScrollX;
				case 'ScrollXInner': return $this->strScrollXInner;
				case 'ScrollY': return $this->strScrollY;
				case 'ServerMethod': return $this->strServerMethod;
				case 'ServerMethod1': return $this->strServerMethod1;
				default: 
					try { 
						return parent::__get($strName); 
					} catch (QCallerException $objExc) { 
						$objExc->IncrementOffset(); 
						throw $objExc; 
					}
			}
		}

		public function __set($strName, $mixValue) {
			switch ($strName) {
				case 'Columns':
					try {
						$this->arrColumns = QType::Cast($mixValue, QType::ArrayType);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aoColumns', $this->arrColumns);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ColumnDefs':
					try {
						$this->arrColumnDefs = QType::Cast($mixValue, QType::ArrayType);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aoColumnDefs', $this->arrColumnDefs);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Language':
					$this->mixLanguage = $mixValue;
				
					if ($this->OnPage) {
						$this->CallJqUiMethod(true, 'option', 'oLanguage', $mixValue);
					}
					break;

				case 'Data':
					try {
						$this->arrData = QType::Cast($mixValue, QType::ArrayType);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aaData', $this->arrData);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Sorting':
					try {
						$this->arrSorting = QType::Cast($mixValue, QType::ArrayType);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aaSorting', $this->arrSorting);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'SortingFixed':
					try {
						$this->arrSortingFixed = QType::Cast($mixValue, QType::ArrayType);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aaSortingFixed', $this->arrSortingFixed);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'LengthMenuArray':
					try {
						$this->intLengthMenuArray = QType::Cast($mixValue, 'int');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aLengthMenu', $this->intLengthMenuArray);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'SearchColsArray':
					try {
						$this->mixSearchColsArray = QType::Cast($mixValue, 'object');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'aoSearchCols', $this->mixSearchColsArray);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StripeClassesArray':
					try {
						$this->strStripeClassesArray = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'asStripeClasses', $this->strStripeClassesArray);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'AutoWidth':
					try {
						$this->blnAutoWidth = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bAutoWidth', $this->blnAutoWidth);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'DeferRender':
					try {
						$this->blnDeferRender = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bDeferRender', $this->blnDeferRender);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Destroy':
					try {
						$this->blnDestroy = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bDestroy', $this->blnDestroy);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Filter':
					try {
						$this->blnFilter = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bFilter', $this->blnFilter);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Info':
					try {
						$this->blnInfo = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bInfo', $this->blnInfo);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'JQueryUI':
					try {
						$this->blnJQueryUI = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bJQueryUI', $this->blnJQueryUI);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'LengthChange':
					try {
						$this->blnLengthChange = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bLengthChange', $this->blnLengthChange);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Paginate':
					try {
						$this->blnPaginate = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bPaginate', $this->blnPaginate);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Processing':
					try {
						$this->blnProcessing = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bProcessing', $this->blnProcessing);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Retrieve':
					try {
						$this->blnRetrieve = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bRetrieve', $this->blnRetrieve);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollAutoCss':
					try {
						$this->blnScrollAutoCss = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bScrollAutoCss', $this->blnScrollAutoCss);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollCollapse':
					try {
						$this->blnScrollCollapse = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bScrollCollapse', $this->blnScrollCollapse);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollInfinite':
					try {
						$this->blnScrollInfinite = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bScrollInfinite', $this->blnScrollInfinite);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerSide':
					try {
						$this->blnServerSide = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bServerSide', $this->blnServerSide);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerSide1':
					try {
						$this->blnServerSide1 = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bServerSide', $this->blnServerSide1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Sort':
					try {
						$this->blnSort = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bSort', $this->blnSort);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'SortCellsTop':
					try {
						$this->blnSortCellsTop = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bSortCellsTop', $this->blnSortCellsTop);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'SortClasses':
					try {
						$this->blnSortClasses = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bSortClasses', $this->blnSortClasses);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StateSave':
					try {
						$this->blnStateSave = QType::Cast($mixValue, QType::Boolean);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'bStateSave', $this->blnStateSave);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'CookieCallback':
					try {
						$this->mixCookieCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnCookieCallback', $this->mixCookieCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'CreatedRow':
					try {
						$this->mixCreatedRow = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnCreatedRow', $this->mixCreatedRow);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'DrawCallback':
					try {
						$this->mixDrawCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnDrawCallback', $this->mixDrawCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FooterCallback':
					try {
						$this->mixFooterCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnFooterCallback', $this->mixFooterCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatNumber':
					try {
						$this->mixFormatNumber = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnFormatNumber', $this->mixFormatNumber);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'HeaderCallback':
					try {
						$this->mixHeaderCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnHeaderCallback', $this->mixHeaderCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'InfoCallback':
					try {
						$this->mixInfoCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnInfoCallback', $this->mixInfoCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'InitComplete':
					try {
						$this->mixInitComplete = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnInitComplete', $this->mixInitComplete);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'PreDrawCallback':
					try {
						$this->mixPreDrawCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnPreDrawCallback', $this->mixPreDrawCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'RowCallback':
					try {
						$this->mixRowCallback = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnRowCallback', $this->mixRowCallback);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerData':
					try {
						$this->mixServerData = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnServerData', $this->mixServerData);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerData1':
					try {
						$this->mixServerData1 = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnServerData', $this->mixServerData1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerParams':
					try {
						$this->mixServerParams = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnServerParams', $this->mixServerParams);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerParams1':
					try {
						$this->mixServerParams1 = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnServerParams', $this->mixServerParams1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StateLoad':
					try {
						$this->mixStateLoad = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnStateLoad', $this->mixStateLoad);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StateLoaded':
					try {
						$this->mixStateLoaded = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnStateLoaded', $this->mixStateLoaded);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StateLoadParams':
					try {
						$this->mixStateLoadParams = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnStateLoadParams', $this->mixStateLoadParams);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StateSave1':
					try {
						$this->mixStateSave1 = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnStateSave', $this->mixStateSave1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'StateSaveParams':
					try {
						$this->mixStateSaveParams = QType::Cast($mixValue, 'QJsClosure');
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'fnStateSaveParams', $this->mixStateSaveParams);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'CookieDuration':
					try {
						$this->intCookieDuration = QType::Cast($mixValue, QType::Integer);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'iCookieDuration', $this->intCookieDuration);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'DeferLoading':
					try {
						$this->intDeferLoading = QType::Cast($mixValue, QType::Integer);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'iDeferLoading', $this->intDeferLoading);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'DisplayLength':
					try {
						$this->intDisplayLength = QType::Cast($mixValue, QType::Integer);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'iDisplayLength', $this->intDisplayLength);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'DisplayStart':
					try {
						$this->intDisplayStart = QType::Cast($mixValue, QType::Integer);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'iDisplayStart', $this->intDisplayStart);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollLoadGap':
					try {
						$this->intScrollLoadGap = QType::Cast($mixValue, QType::Integer);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'iScrollLoadGap', $this->intScrollLoadGap);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'TabIndex':
					try {
						$this->intTabIndex = QType::Cast($mixValue, QType::Integer);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'iTabIndex', $this->intTabIndex);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Search':
					$this->mixSearch = $mixValue;
				
					if ($this->OnPage) {
						$this->CallJqUiMethod(true, 'option', 'oSearch', $mixValue);
					}
					break;

				case 'AjaxDataProp':
					try {
						$this->strAjaxDataProp = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sAjaxDataProp', $this->strAjaxDataProp);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'AjaxDataProp1':
					try {
						$this->strAjaxDataProp1 = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sAjaxDataProp', $this->strAjaxDataProp1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'AjaxSource':
					try {
						$this->strAjaxSource = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sAjaxSource', $this->strAjaxSource);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'AjaxSource1':
					try {
						$this->strAjaxSource1 = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sAjaxSource', $this->strAjaxSource1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'CookiePrefix':
					try {
						$this->strCookiePrefix = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sCookiePrefix', $this->strCookiePrefix);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Dom':
					try {
						$this->strDom = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sDom', $this->strDom);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'PaginationType':
					try {
						$this->strPaginationType = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sPaginationType', $this->strPaginationType);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollX':
					try {
						$this->strScrollX = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sScrollX', $this->strScrollX);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollXInner':
					try {
						$this->strScrollXInner = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sScrollXInner', $this->strScrollXInner);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ScrollY':
					try {
						$this->strScrollY = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sScrollY', $this->strScrollY);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerMethod':
					try {
						$this->strServerMethod = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sServerMethod', $this->strServerMethod);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'ServerMethod1':
					try {
						$this->strServerMethod1 = QType::Cast($mixValue, QType::String);
						if ($this->OnPage) {
							$this->CallJqUiMethod(true, 'option', 'sServerMethod', $this->strServerMethod1);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}


				default:
					try {
						parent::__set($strName, $mixValue);
						break;
					} catch (QCallerException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}
			}
		}
	}

?>
