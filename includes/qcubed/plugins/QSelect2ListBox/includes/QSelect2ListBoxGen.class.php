<?php
	/**
	 * The abstract QSelect2ListBoxGen class defined here is
	 * code-generated and contains options, events and methods scraped from the
	 * JQuery UI documentation Web site. It is not generated by the typical
	 * codegen process, but rather is generated periodically by the core QCubed
	 * team and checked in. However, the code to generate this file is
	 * in the assets/_core/php/_devetools/jquery_ui_gen/jq_control_gen.php file
	 * and you can regenerate the files if you need to.
	 *
	 * The comments in this file are taken from the JQuery UI site, so they do
	 * not always make sense with regard to QCubed. They are simply provided
	 * as reference. Note that this is very low-level code, and does not always
	 * update QCubed state variables. See the QSelect2ListBoxBase 
	 * file, which contains code to interface between this generated file and QCubed.
	 *
	 * Because subsequent re-code generations will overwrite any changes to this
	 * file, you should leave this file unaltered to prevent yourself from losing
	 * any information or code changes.  All customizations should be done by
	 * overriding existing or implementing new methods, properties and variables
	 * in the QSelect2ListBox class file.
	 *
	 */

	/* Custom event classes for this control */
	
	

	/* Custom "property" event classes for this control */

	/**
	 * @property string $ContainerWidth Controls the width style attribute of the Select2 container div. The following values are supported: "off", "element", "copy", "resolve"
	 * @property integer $MinimumInputLength Number of characters necessary to start a search
	 * @property integer $MinimumResultsForSearch The minimum number of results that must be initially (after opening the dropdown for the first time) populated in order to keep the search field. This is useful for cases where local data is used with just a few results, in which case the search box is not very useful and wastes screen space.
	 * @property integer $MaximumSelectionSize The maximum number of items that can be selected in a multi-select control. If this number is less than 1 selection is not limited. Once the number of selected items reaches the maximum specified the contents of the dropdown will be populated by the formatSelectionTooBig function
	 * @property string $Placeholder Initial value that is selected if no other selection is made. The placeholder can also be specified as a data-placeholder attribute on the select or input element that Select2 is attached to.
	 * @property string $Separator Separator character or string used to delimit ids in value attribute of the multi-valued selects. The default delimiter is the , character.
	 * @property boolean $AllowClear Whether or not a clear button is displayed when the select box has a selection. The button, when clicked, resets the value of the select box back to the placeholder, thus this option is only available when the placeholder is specified.
	 * @property boolean $CloseOnSelect If set to false the dropdown is not closed after a selection is made, allowing for rapid selection of multiple items. By default this option is disabled.
	 * @property boolean $OpenOnEnter If set to true the dropdown is opened when the user presses the enter key and Select2 is closed. By default this option is enabled.
	 * @property QJsClosure $Matcher Used to determine whether or not the search term matches an option when a built-in query function is used. The built in query function is used when Select2 is attached to a select, or the local or tags helpers are used.
	 * @property QJsClosure $FormatSelection Function used to render the current selection.
	 * @property QJsClosure $FormatResult Function used to render a result that the user can select.
	 * @property QJsClosure $FormatResultCssClass Function used to add css classes to result elements
	 * @property QJsClosure $FormatNoMatches Function used to render the "No matches" message
	 * @property QJsClosure $FormatSearching Function used to render the "Searching..." message that is displayed while search is in progress
	 * @property QJsClosure $FormatInputTooShort Function used to render the "Search input too short" message
	 * @property QJsClosure $FormatSelectionTooBig Function used to render the "You cannot select any more choices" message
	 * @property QJsClosure $FormatLoadMore Function used to render the "Loading more results..." message
	 * @property QJsClosure $CreateSearchChoice Creates a new selectable choice from user's search term. Allows creation of choices not available via the query function. Useful when the user can create choices on the fly, eg for the 'tagging' usecase.
	 * @property QJsClosure $InitSelection Called when Select2 is created to allow the user to initialize the selection based on the value of the element select2 is attached to.
	 * @property QJsClosure $Tokenizer A tokenizer function can process the input typed into the search field after every keystroke and extract and select choices. This is useful, for example, in tagging scenarios where the user can create tags quickly by separating them with a comma or a space instead of pressing enter.
	 * @property array $TokenSeparators An array of strings that define token separators for the default tokenizer function. By default, this option is set to an empty array which means tokenization using the default tokenizer is disabled. Usually it is sensible to set this option to a value similar to [",", " "]
	 * @property QJsClosure $Query Function used to query results for the search term.
	 * @property mixed $Ajax Options for the built in ajax query function. This object acts as a shortcut for having to manually write a function that performs ajax requests. The built-in function supports more advanced features such as throttling and dropping out-of-order responses.
	 * @property mixed $Data Options for the built in query function that works with arrays.
	 * @property mixed $Tags Puts Select2 into 'tagging' mode where the user can add new choices and pre-existing tags are provided via this options attribute which is either an array or a function that returns an array of objects or strings
	 * @property mixed $ContainerCss Inline css that will be added to select2's container. Either an object containing css property/value key pairs or a function that returns such an object.
	 * @property mixed $ContainerCssClass Css class that will be added to select2's container tag
	 * @property mixed $DropdownCss Inline css that will be added to select2's dropdown container. Either an object containing css property/value key pairs or a function that returns such an object.
	 * @property mixed $DropdownCssClass Css class that will be added to select2's dropdown container
	 * @property QJsClosure $EscapeMarkup Function used to post-process markup returned from formatter functions. By default this function escapes html entities to prevent javascript injection.
	 */

	class QSelect2ListBoxGen extends QListBox	{
		protected $strJavaScripts = __JQUERY_EFFECTS__;
		protected $strStyleSheets = __JQUERY_CSS__;
		/** @var string */
		protected $strContainerWidth = null;
		/** @var integer */
		protected $intMinimumInputLength;
		/** @var integer */
		protected $intMinimumResultsForSearch;
		/** @var integer */
		protected $intMaximumSelectionSize;
		/** @var string */
		protected $strPlaceholder;
		/** @var string */
		protected $strSeparator;
		/** @var boolean */
		protected $blnAllowClear;
		/** @var boolean */
		protected $blnCloseOnSelect;
		/** @var boolean */
		protected $blnOpenOnEnter;
		/** @var QJsClosure */
		protected $mixMatcher;
		/** @var QJsClosure */
		protected $mixFormatSelection;
		/** @var QJsClosure */
		protected $mixFormatResult;
		/** @var QJsClosure */
		protected $mixFormatResultCssClass;
		/** @var QJsClosure */
		protected $mixFormatNoMatches;
		/** @var QJsClosure */
		protected $mixFormatSearching;
		/** @var QJsClosure */
		protected $mixFormatInputTooShort;
		/** @var QJsClosure */
		protected $mixFormatSelectionTooBig;
		/** @var QJsClosure */
		protected $mixFormatLoadMore;
		/** @var QJsClosure */
		protected $mixCreateSearchChoice;
		/** @var QJsClosure */
		protected $mixInitSelection;
		/** @var QJsClosure */
		protected $mixTokenizer;
		/** @var array */
		protected $arrTokenSeparators;
		/** @var QJsClosure */
		protected $mixQuery;
		/** @var mixed */
		protected $mixAjax;
		/** @var mixed */
		protected $mixData;
		/** @var mixed */
		protected $mixTags;
		/** @var mixed */
		protected $mixContainerCss;
		/** @var mixed */
		protected $mixContainerCssClass;
		/** @var mixed */
		protected $mixDropdownCss;
		/** @var mixed */
		protected $mixDropdownCssClass;
		/** @var QJsClosure */
		protected $mixEscapeMarkup;

		protected function makeJsProperty($strProp, $strKey) {
			$objValue = $this->$strProp;
			if (null === $objValue) {
				return '';
			}

			return $strKey . ': ' . JavaScriptHelper::toJsObject($objValue) . ', ';
		}

		protected function makeJqOptions() {
			$strJqOptions = '';
			$strJqOptions .= $this->makeJsProperty('ContainerWidth', 'width');
			$strJqOptions .= $this->makeJsProperty('MinimumInputLength', 'minimumInputLength');
			$strJqOptions .= $this->makeJsProperty('MinimumResultsForSearch', 'minimumResultsForSearch');
			$strJqOptions .= $this->makeJsProperty('MaximumSelectionSize', 'maximumSelectionSize');
			$strJqOptions .= $this->makeJsProperty('Placeholder', 'placeholder');
			$strJqOptions .= $this->makeJsProperty('Separator', 'separator');
			$strJqOptions .= $this->makeJsProperty('AllowClear', 'allowClear');
			$strJqOptions .= $this->makeJsProperty('CloseOnSelect', 'closeOnSelect');
			$strJqOptions .= $this->makeJsProperty('OpenOnEnter', 'openOnEnter');
			$strJqOptions .= $this->makeJsProperty('Matcher', 'matcher');
			$strJqOptions .= $this->makeJsProperty('FormatSelection', 'formatSelection');
			$strJqOptions .= $this->makeJsProperty('FormatResult', 'formatResult');
			$strJqOptions .= $this->makeJsProperty('FormatResultCssClass', 'formatResultCssClass');
			$strJqOptions .= $this->makeJsProperty('FormatNoMatches', 'formatNoMatches');
			$strJqOptions .= $this->makeJsProperty('FormatSearching', 'formatSearching');
			$strJqOptions .= $this->makeJsProperty('FormatInputTooShort', 'formatInputTooShort');
			$strJqOptions .= $this->makeJsProperty('FormatSelectionTooBig', 'formatSelectionTooBig');
			$strJqOptions .= $this->makeJsProperty('FormatLoadMore', 'formatLoadMore');
			$strJqOptions .= $this->makeJsProperty('CreateSearchChoice', 'createSearchChoice');
			$strJqOptions .= $this->makeJsProperty('InitSelection', 'initSelection');
			$strJqOptions .= $this->makeJsProperty('Tokenizer', 'tokenizer');
			$strJqOptions .= $this->makeJsProperty('TokenSeparators', 'tokenSeparators');
			$strJqOptions .= $this->makeJsProperty('Query', 'query');
			$strJqOptions .= $this->makeJsProperty('Ajax', 'ajax');
			$strJqOptions .= $this->makeJsProperty('Data', 'data');
			$strJqOptions .= $this->makeJsProperty('Tags', 'tags');
			$strJqOptions .= $this->makeJsProperty('ContainerCss', 'containerCss');
			$strJqOptions .= $this->makeJsProperty('ContainerCssClass', 'containerCssClass');
			$strJqOptions .= $this->makeJsProperty('DropdownCss', 'dropdownCss');
			$strJqOptions .= $this->makeJsProperty('DropdownCssClass', 'dropdownCssClass');
			$strJqOptions .= $this->makeJsProperty('EscapeMarkup', 'escapeMarkup');
			if ($strJqOptions) $strJqOptions = substr($strJqOptions, 0, -2);
			return $strJqOptions;
		}

		public function getJqSetupFunction() {
			return 'select2';
		}

		public function GetControlJavaScript() {
			return sprintf('jQuery("#%s").%s({%s})', $this->getJqControlId(), $this->getJqSetupFunction(), $this->makeJqOptions());
		}

		public function GetEndScript() {
			$str = '';
			if ($this->getJqControlId() !== $this->ControlId) {
				// #845: if the element receiving the jQuery UI events is different than this control
				// we need to clean-up the previously attached event handlers, so that they are not duplicated 
				// during the next ajax update which replaces this control.
				$str = sprintf('jQuery("#%s").off(); ', $this->getJqControlId());
			}
			return $str . $this->GetControlJavaScript() . '; ' . parent::GetEndScript();
		}
		
		/**
		 * Call a JQuery UI Method on the object. Takes variable number of arguments.
		 * 
		 * @param string $strMethodName the method name to call
		 * @internal param $mixed [optional] $mixParam1
		 * @internal param $mixed [optional] $mixParam2
		 */
		protected function CallJqUiMethod($strMethodName /*, ... */) {
			$args = func_get_args();

			$strArgs = JavaScriptHelper::toJsObject($args);
			$strJs = sprintf('jQuery("#%s").%s(%s)',
				$this->getJqControlId(),
				$this->getJqSetupFunction(),
				substr($strArgs, 1, strlen($strArgs)-2));	// params without brackets
			QApplication::ExecuteJavaScript($strJs);
		}




		public function __get($strName) {
			switch ($strName) {
				case 'ContainerWidth': return $this->strContainerWidth;
				case 'MinimumInputLength': return $this->intMinimumInputLength;
				case 'MinimumResultsForSearch': return $this->intMinimumResultsForSearch;
				case 'MaximumSelectionSize': return $this->intMaximumSelectionSize;
				case 'Placeholder': return $this->strPlaceholder;
				case 'Separator': return $this->strSeparator;
				case 'AllowClear': return $this->blnAllowClear;
				case 'CloseOnSelect': return $this->blnCloseOnSelect;
				case 'OpenOnEnter': return $this->blnOpenOnEnter;
				case 'Matcher': return $this->mixMatcher;
				case 'FormatSelection': return $this->mixFormatSelection;
				case 'FormatResult': return $this->mixFormatResult;
				case 'FormatResultCssClass': return $this->mixFormatResultCssClass;
				case 'FormatNoMatches': return $this->mixFormatNoMatches;
				case 'FormatSearching': return $this->mixFormatSearching;
				case 'FormatInputTooShort': return $this->mixFormatInputTooShort;
				case 'FormatSelectionTooBig': return $this->mixFormatSelectionTooBig;
				case 'FormatLoadMore': return $this->mixFormatLoadMore;
				case 'CreateSearchChoice': return $this->mixCreateSearchChoice;
				case 'InitSelection': return $this->mixInitSelection;
				case 'Tokenizer': return $this->mixTokenizer;
				case 'TokenSeparators': return $this->arrTokenSeparators;
				case 'Query': return $this->mixQuery;
				case 'Ajax': return $this->mixAjax;
				case 'Data': return $this->mixData;
				case 'Tags': return $this->mixTags;
				case 'ContainerCss': return $this->mixContainerCss;
				case 'ContainerCssClass': return $this->mixContainerCssClass;
				case 'DropdownCss': return $this->mixDropdownCss;
				case 'DropdownCssClass': return $this->mixDropdownCssClass;
				case 'EscapeMarkup': return $this->mixEscapeMarkup;
				default:
					try { 
						return parent::__get($strName); 
					} catch (QCallerException $objExc) { 
						$objExc->IncrementOffset(); 
						throw $objExc; 
					}
			}
		}

		public function __set($strName, $mixValue) {
			switch ($strName) {
				case 'ContainerWidth':
					try {
						$this->strContainerWidth = QType::Cast($mixValue, QType::String);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'width', $this->strContainerWidth);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'MinimumInputLength':
					try {
						$this->intMinimumInputLength = QType::Cast($mixValue, QType::Integer);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'minimumInputLength', $this->intMinimumInputLength);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'MinimumResultsForSearch':
					try {
						$this->intMinimumResultsForSearch = QType::Cast($mixValue, QType::Integer);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'minimumResultsForSearch', $this->intMinimumResultsForSearch);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'MaximumSelectionSize':
					try {
						$this->intMaximumSelectionSize = QType::Cast($mixValue, QType::Integer);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'maximumSelectionSize', $this->intMaximumSelectionSize);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Placeholder':
					try {
						$this->strPlaceholder = QType::Cast($mixValue, QType::String);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'placeholder', $this->strPlaceholder);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Separator':
					try {
						$this->strSeparator = QType::Cast($mixValue, QType::String);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'separator', $this->strSeparator);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'AllowClear':
					try {
						$this->blnAllowClear = QType::Cast($mixValue, QType::Boolean);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'allowClear', $this->blnAllowClear);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'CloseOnSelect':
					try {
						$this->blnCloseOnSelect = QType::Cast($mixValue, QType::Boolean);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'closeOnSelect', $this->blnCloseOnSelect);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'OpenOnEnter':
					try {
						$this->blnOpenOnEnter = QType::Cast($mixValue, QType::Boolean);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'openOnEnter', $this->blnOpenOnEnter);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Matcher':
					try {
						$this->mixMatcher = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'matcher', $this->mixMatcher);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatSelection':
					try {
						$this->mixFormatSelection = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatSelection', $this->mixFormatSelection);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatResult':
					try {
						$this->mixFormatResult = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatResult', $this->mixFormatResult);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatResultCssClass':
					try {
						$this->mixFormatResultCssClass = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatResultCssClass', $this->mixFormatResultCssClass);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatNoMatches':
					try {
						$this->mixFormatNoMatches = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatNoMatches', $this->mixFormatNoMatches);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatSearching':
					try {
						$this->mixFormatSearching = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatSearching', $this->mixFormatSearching);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatInputTooShort':
					try {
						$this->mixFormatInputTooShort = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatInputTooShort', $this->mixFormatInputTooShort);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatSelectionTooBig':
					try {
						$this->mixFormatSelectionTooBig = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatSelectionTooBig', $this->mixFormatSelectionTooBig);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'FormatLoadMore':
					try {
						$this->mixFormatLoadMore = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'formatLoadMore', $this->mixFormatLoadMore);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'CreateSearchChoice':
					try {
						$this->mixCreateSearchChoice = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'createSearchChoice', $this->mixCreateSearchChoice);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'InitSelection':
					try {
						$this->mixInitSelection = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'initSelection', $this->mixInitSelection);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Tokenizer':
					try {
						$this->mixTokenizer = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'tokenizer', $this->mixTokenizer);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'TokenSeparators':
					try {
						$this->arrTokenSeparators = QType::Cast($mixValue, QType::ArrayType);
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'tokenSeparators', $this->arrTokenSeparators);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Query':
					try {
						$this->mixQuery = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'query', $this->mixQuery);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}

				case 'Ajax':
					$this->mixAjax = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'ajax', $mixValue);
					}
					break;

				case 'Data':
					$this->mixData = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'data', $mixValue);
					}
					break;

				case 'Tags':
					$this->mixTags = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'tags', $mixValue);
					}
					break;

				case 'ContainerCss':
					$this->mixContainerCss = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'containerCss', $mixValue);
					}
					break;

				case 'ContainerCssClass':
					$this->mixContainerCssClass = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'containerCssClass', $mixValue);
					}
					break;

				case 'DropdownCss':
					$this->mixDropdownCss = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'dropdownCss', $mixValue);
					}
					break;

				case 'DropdownCssClass':
					$this->mixDropdownCssClass = $mixValue;
				
					if ($this->Rendered) {
						$this->CallJqUiMethod('option', 'dropdownCssClass', $mixValue);
					}
					break;

				case 'EscapeMarkup':
					try {
						$this->mixEscapeMarkup = QType::Cast($mixValue, 'QJsClosure');
						if ($this->Rendered) {
							$this->CallJqUiMethod('option', 'escapeMarkup', $this->mixEscapeMarkup);
						}
						break;
					} catch (QInvalidCastException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}


				default:
					try {
						parent::__set($strName, $mixValue);
						break;
					} catch (QCallerException $objExc) {
						$objExc->IncrementOffset();
						throw $objExc;
					}
			}
		}
	}

?>
